---
layout: post
title:  "C++基础知识查漏补缺"
categories: C/C++
tags: C++
author: ZhangJie
---

* content
{:toc}
C++基础知识查漏补缺。




### 输入输出流

流（stream）：随着时间的推移，字符是顺序生成或消耗的。

输入运算符(">>")/输出运算符("<<")返回其左侧的运算对象：
```
std::cout << "hello world!" << std::endl;

// 等价于:
(std::cout << "hello world!") << std::endl;
```

当使用一个istream对象作为条件时，其效果是检测流的状态：
```
int val = 0;

if (std::cin >> val) {
    std::cout << val << std::endl;      // 输入“整数”回车后会执行该语句
}
else {
    std::cerr << "error!" << std::endl; // 输入“字符串”回车后会执行该语句
}
```

istream与ostream属于不能被拷贝的类型，只能通过引用来传递它们；因为读取和写入的操作会改变流的内容，所以只能是普通引用，而非对常量的引用。


### 类的成员变量初始化

C++11中类的成员变量初始化的几种不同形式及差异：
```
// VS2015中
class A
{
private:
    double d = 12.34;
    int b = d;    // warning C4244: “初始化”: 从“double”转换到“int”，可能丢失数据
    int a{d};     // error C2397: 从“double”转换到“int”需要收缩转换
    int c = {d};  // error C2397: 从“double”转换到“int”需要收缩转换
};

```

### decltype类型指示符

decltype((a))的结果永远是引用，decltype(a)只有当a本身是引用时才是引用：
```
int a = 0;
decltype((a)) b;  // error C2530: “b”: 必须初始化引用
decltype(a) c;


int m = 0;
int& n = m;
decltype(n) v;  // error C2530: “v”: 必须初始化引用
```

decltype作用于某个函数时，返回函数类型而非指针类型，可以显式地加上*以表明需要返回指针。


### std::string

字符串字面值与string是不同的类型
```
std::string s1 = "Hello" + "world";  // 错误, 必须保证每个(+)的两侧的运算对象至少有一个是std::string

std::string s2 = ",";
std::string s3 = "Hello" + s2 + "world";
```

无法保证c_str()返回的数组一直有效，如果执行完c_str()函数后想一直都能使用其返回的数组，最好将该数组重新拷贝一份。
```
std::string s = "abc";
const char* ch = s.c_str();
printf("%s\n", ch);  // abc
s = "123";
printf("%s\n", ch);  // 123
```

### std::vector

vector是模板而非类型，vector<int>是类型。

因为引用不是对象，所以不存在包含引用的vector。

因为所有标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没有定义<运算符，所以for循环中使用!=而非<进行判断。

size_t是一种机器相关的无符号类型，它被设计的足够大，能够表示内存中任意对象的大小。


### 左值和右值

当一个对象被用作“右值”的时候，用的是对象的值（内容）；当对象被用作“左值”的时候，用的是对象的身份（在内存中的位置）。


### 含有可变形参的函数

如果函数的实参数量未知，但是全部实参的类型都相同，可以使用initializer_list类型的形参（C++11）。
```
#include <iostream>
#include <initializer_list>

void show(std::initializer_list<int> il)
{
    for (auto item : il) {
        std::cout << item << std::endl;
    }
}

int main()
{
    show({ 1,2,3,4,5,6 });
    return 0;
}
```

### 构造函数

构造函数不能被声明成const的。


### static
```
class A;

class B
{
private:
    static A a_;  // 正确：静态成员可以是不完全类型
};
```

